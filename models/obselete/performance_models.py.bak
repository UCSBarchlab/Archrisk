from base.sheet import *
from collections import defaultdict
from models.distributions import Distribution
from models.math_models import MathModel

class PerformanceModel(MathModel):
    area = 256
    perf_target = 'speedup'
    # Too much to simulate with MC, need more efficient methods.
    #designs = [1, 2, 4, 8, 16, 32, 64, 128, 256]
    designs = [8, 16, 32, 64, 128, 256]
    #designs = [4]
    def __init__(self, selected_model, risk_function):
        self.sheet1 = Sheet()
        self.sheet1.addSyms(
                MathModel.index_syms +
                MathModel.config_syms +
                MathModel.perf_syms +
                MathModel.stat_syms +
                MathModel.power_syms)
        self.sheet1.addFuncs(MathModel.custom_funcs)
        if selected_model == 'symmetric':
            model = MathModel.symm_exprs
        elif selected_model == 'asymmetric':
            model = MathModel.asymm_exprs
        elif selected_model == 'dynamic':
            model = MathModel.dynamic_exprs
        elif selected_model == 'hete':
            model = MathModel.hete_exprs
        else:
            raise ValueError('Unrecgonized model: {}'.format(selected_model))

        self.given = defaultdict()
        self.index_bounds = defaultdict()
        self.ims = defaultdict()
        self.add_given('area_total', self.__class__.area)
        self.target = [self.__class__.perf_target]
        self.sheet1.addExprs(MathModel.common_exprs + model)
        self.sheet1.addPreds(response=self.target)
        self.risk_func = risk_function

    def gen_feed(self, k2v):
        feed = []
        for k, v in k2v.iteritems():
            feed += [(k, v)]
        return feed

    def compute(self, app):
        #logging.debug('Solving app: {}'.format(app.get_printable()))
        given = self.gen_feed(self.given) + app.gen_feed()
        ims = self.gen_feed(self.ims)
        logging.debug('PerfModel -- Given: {} -- Intermediates: {}'.format(
            given, {k: v.func.__name__ for k, v in self.ims.iteritems()}))
        self.sheet1.addPreds(given=given, bounds=self.index_bounds, intermediates=ims)
        result = self.sheet1.compute() # Map of all target results.
        return result

    def dump(self):
        # Dumping all expressions.
        self.sheet1.dump()
        # Dumping risk function used.
        print self.risk_func

    def add_index_bounds(self, idx_base, lower=0, upper=None):
        assert upper
        self.index_bounds[idx_base] = (lower, upper)

    def add_given(self, name, val):
        self.given[name] = val

    def add_uncertain(self, name, partial_func):
        self.ims[name] = partial_func

    def get_risk(self, ref, d2perf):
        """ Compute risk for d2perf w.r.t. ref

        Args:
            ref: reference performance bar
            d2perf: performance array-like

        Returns:
            single float (mean risk)
        """
        return {k: self.risk_func.get_risk(ref, v) for k, v in d2perf.iteritems()}

    def get_mean(self, d2uc):
        """ Extracts mean performance.
        """
        return {k: self.get_numerical(v) for k, v in d2uc.iteritems()}

    def get_std(self, d2uc):
        return {k: np.sqrt(self.get_var(v)) for k, v in d2uc.iteritems()}

    def apply_candidate(self, candidate, num_func, perf_func, app):
        """ Try on a certain given design candidate.

        Args:
            candidate: design point
            num_func: function to generate core number distributions.
            perf_func: function to generate core performance distributions.
            app: application to solve.

        Returns:
            perf: result performance distribution.
        """
        assert(len(candidate) == len(self.designs))
        area_left = self.__class__.area - sum([x * y for x, y in zip(candidate, self.designs)])
        candidate_ns, candidate_ps = [], []
        if area_left > 0:
            candidate_ns.append(num_func(area_left, area_left))
            candidate_ps.append(perf_func(area_left))
            working_core_num += 1
        for x, y in zip(candidate, self.designs):
            if x > 0:
                num_cur = num_func(y, x * y)
                working_core_num += num_cur
                candidate_ns.append(num_cur)
                perf_cur = perf_func(y)
                candidate_ps.append(perf_cur)
        score_perf = Distribution.ConditionalMax(candidate_ns, candidate_ps)
        pcore_perf = sum([n * p for n, p in zip(candidate_ns, candidate_ps)])
        self.add_given('score_perf', score_perf)
        self.add_given('working_core_num', working_core_num)
        self.add_given('pcore_perf', pcore_perf)
        perf = self.compute(app)[self.perf_target]
        logging.debug('PerfModel -- Applying result: {}'.format(perf))
        return perf

    def iter_through_design(self, d2perf, ith, stop,
            candidate, core_nums, core_perfs,
            num_func, perf_func, app):
        """ Place cores on chip, or evaluate a chip when a candidate core placement has been selected.

        Args:
            d2perf: result, tuple(candidate) -> perf distribution.
            ith: the i-th design under inspection.
            stop: when to stop considering more designs.
            candidate: current candidate core placement list.
            core_nums: current core num distributions for each design in the candidate.
            core_perfs: similar to above but for perf distributions.
            num_func: function to generate core number distributions.
            perf_func: similar to above but for perf distributions.
            app: application to solve.

        Returns:
            d2perf
        """
        area_left = self.__class__.area - sum(
                [x * y for x, y in zip(candidate, self.designs)])
        assert(area_left >= 0)
        if ith == stop:
            logging.debug('================'.format(tag))
            logging.debug('PerfModel -- Candidate: {}'.format(tag))
            # Have a candidate configuration.
            tag = tuple(candidate + [area_left])
            # Construct candidate core numbers/performances.
            candidate_ns = [n for n in core_nums if n != 0]
            candidate_ps = [p for (p, n) in zip(core_perfs, core_nums) if n != 0]
            working_core_num = 0
            if area_left > 0:
                candidate_ns.append(num_func(area_left, area_left))
                candidate_ps.append(perf_func(area_left))
                working_core_num += 1
            assert(len(candidate_ns) == len(candidate_ps))
            logging.debug('================'.format(tag))
            logging.debug('PerfModel -- Candidate: {}'.format(tag))
            logging.debug('PerfModel -- candidate_ps: {}    candidate ns: {}'.format(
                candidate_ps, candidate_ns))
            score_perf = Distribution.ConditionalMax(candidate_ns, candidate_ps)
            working_core_num += sum(core_nums)
            pcore_perf = sum([n * p for n, p in zip(candidate_ns, candidate_ps)])
            self.add_given('score_perf', score_perf)
            self.add_given('working_core_num', working_core_num)
            self.add_given('pcore_perf', pcore_perf)
            result = self.compute(app)
            d2perf[tag] = result[self.perf_target]
            logging.debug(('PerfModel -- score_perf: {}\n' + 
                'PerfModel -- working_core_num: {}\n' +
                'PerfModel -- pcore_perf: {}\n' +
                'PerfModel -- perf: {}').format(
                score_perf, working_core_num, pcore_perf, d2perf[tag]))
        else:
            # If we are still trying to place a core.
            d_cur = self.designs[ith]
            i = 0
            while (i < area_left / self.designs[ith] + 1):
                candidate[ith] = i
                if i > 0:
                    core_nums[ith] = num_func(d_cur, i * d_cur)
                    core_perfs[ith] = (core_perfs[ith]
                            if core_perfs[ith] else perf_func(d_cur))
                    #core_perfs[ith] = perf_func(d_cur)
                self.iter_through_design(
                        d2perf, ith+1, stop,
                        candidate, core_nums, core_perfs,
                        num_func, perf_func, app)
                candidate[ith] = 0
                core_nums[ith] = 0
                #core_perfs[ith] = 0
                # We double the number of cores every time.
                i = 1 if i == 0 else i << 1

    def get_perf(self, num_func, perf_func, app):
        """ Computes peformance distribution over a single app.
        """
        d2perf = defaultdict()
        # heterogeous chip
        n_designs = len(self.designs)
        candidate = [0] * n_designs
        core_nums = [0] * n_designs
        core_perfs = [None] * n_designs
        self.iter_through_design(
                d2perf, 0, n_designs,
                candidate, core_nums, core_perfs,
                num_func, perf_func, app)
        return d2perf

    def print_latex(self):
        self.sheet1.printLatex()
